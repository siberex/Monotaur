{"version":3,"file":"index.js","sources":["../../lib/esm/NBuf.js","../../lib/esm/Node.js","../../lib/esm/Vector.js","../../lib/esm/Plane.js","../../lib/esm/Polygon.js","../../lib/esm/Vertex.js","../../lib/esm/CSG.js"],"sourcesContent":["export class NBuf3 {\n    constructor(ct) {\n        this.top = 0;\n        this.array = new Float32Array(ct);\n    }\n    write(v) {\n        this.array[this.top++] = v.x;\n        this.array[this.top++] = v.y;\n        this.array[this.top++] = v.z;\n    }\n}\nexport class NBuf2 {\n    constructor(ct) {\n        this.top = 0;\n        this.array = new Float32Array(ct);\n    }\n    write(v) {\n        this.array[this.top++] = v.x;\n        this.array[this.top++] = v.y;\n    }\n}\n","/**\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n * by picking a polygon to split along. That polygon (and all other coplanar\n * polygons) are added directly to that node and the other polygons are added to\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\n * no distinction between internal and leaf nodes.\n */\nexport class Node {\n    constructor(polygons) {\n        this.plane = null;\n        this.front = null;\n        this.back = null;\n        this.polygons = [];\n        if (polygons)\n            this.build(polygons);\n    }\n    clone() {\n        const node = new Node();\n        node.plane = this.plane && this.plane.clone();\n        node.front = this.front && this.front.clone();\n        node.back = this.back && this.back.clone();\n        node.polygons = this.polygons.map((p) => p.clone());\n        return node;\n    }\n    // Convert solid space to empty space and empty space to solid space.\n    invert() {\n        for (let i = 0; i < this.polygons.length; i++)\n            this.polygons[i].flip();\n        this.plane && this.plane.flip();\n        this.front && this.front.invert();\n        this.back && this.back.invert();\n        const temp = this.front;\n        this.front = this.back;\n        this.back = temp;\n    }\n    // Recursively remove all polygons in `polygons` that are inside this BSP\n    // tree.\n    clipPolygons(polygons) {\n        if (!this.plane)\n            return polygons.slice();\n        let front = new Array(), back = new Array();\n        for (let i = 0; i < polygons.length; i++) {\n            this.plane.splitPolygon(polygons[i], front, back, front, back);\n        }\n        if (this.front)\n            front = this.front.clipPolygons(front);\n        this.back ? (back = this.back.clipPolygons(back)) : (back = []);\n        return front.concat(back);\n    }\n    // Remove all polygons in this BSP tree that are inside the other BSP tree\n    // `bsp`.\n    clipTo(bsp) {\n        this.polygons = bsp.clipPolygons(this.polygons);\n        if (this.front)\n            this.front.clipTo(bsp);\n        if (this.back)\n            this.back.clipTo(bsp);\n    }\n    // Return a list of all polygons in this BSP tree.\n    allPolygons() {\n        let polygons = this.polygons.slice();\n        if (this.front)\n            polygons = polygons.concat(this.front.allPolygons());\n        if (this.back)\n            polygons = polygons.concat(this.back.allPolygons());\n        return polygons;\n    }\n    // Build a BSP tree out of `polygons`. When called on an existing tree, the\n    // new polygons are filtered down to the bottom of the tree and become new\n    // nodes there. Each set of polygons is partitioned using the first polygon\n    // (no heuristic is used to pick a good split).\n    build(polygons) {\n        if (!polygons.length)\n            return;\n        if (!this.plane)\n            this.plane = polygons[0].plane.clone();\n        const front = [], back = [];\n        for (let i = 0; i < polygons.length; i++) {\n            this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n        }\n        if (front.length) {\n            if (!this.front)\n                this.front = new Node();\n            this.front.build(front);\n        }\n        if (back.length) {\n            if (!this.back)\n                this.back = new Node();\n            this.back.build(back);\n        }\n    }\n}\n","import { Vector3 } from 'three';\n/**\n * Represents a 3D vector.\n */\nexport class Vector {\n    constructor(x = 0, y = 0, z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    copy(v) {\n        this.x = v.x;\n        this.y = v.y;\n        this.z = v.z;\n        return this;\n    }\n    clone() {\n        return new Vector(this.x, this.y, this.z);\n    }\n    negate() {\n        this.x *= -1;\n        this.y *= -1;\n        this.z *= -1;\n        return this;\n    }\n    add(a) {\n        this.x += a.x;\n        this.y += a.y;\n        this.z += a.z;\n        return this;\n    }\n    sub(a) {\n        this.x -= a.x;\n        this.y -= a.y;\n        this.z -= a.z;\n        return this;\n    }\n    times(a) {\n        this.x *= a;\n        this.y *= a;\n        this.z *= a;\n        return this;\n    }\n    dividedBy(a) {\n        this.x /= a;\n        this.y /= a;\n        this.z /= a;\n        return this;\n    }\n    lerp(a, t) {\n        return this.add(new Vector().copy(a).sub(this).times(t));\n    }\n    unit() {\n        return this.dividedBy(this.length());\n    }\n    length() {\n        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));\n    }\n    normalize() {\n        return this.unit();\n    }\n    cross(b) {\n        const a = this.clone();\n        const ax = a.x, ay = a.y, az = a.z;\n        const bx = b.x, by = b.y, bz = b.z;\n        this.x = ay * bz - az * by;\n        this.y = az * bx - ax * bz;\n        this.z = ax * by - ay * bx;\n        return this;\n    }\n    dot(b) {\n        return this.x * b.x + this.y * b.y + this.z * b.z;\n    }\n    toVector3() {\n        return new Vector3(this.x, this.y, this.z);\n    }\n}\n","import { Polygon } from './Polygon';\nimport { Vector } from './Vector';\n/**\n * Represents a plane in 3D space.\n */\nexport class Plane {\n    constructor(normal, w) {\n        this.normal = normal;\n        this.w = w;\n        this.normal = normal;\n        this.w = w;\n    }\n    clone() {\n        return new Plane(this.normal.clone(), this.w);\n    }\n    flip() {\n        this.normal.negate();\n        this.w = -this.w;\n    }\n    // Split `polygon` by this plane if needed, then put the polygon or polygon\n    // fragments in the appropriate lists. Coplanar polygons go into either\n    // `coplanarFront` or `coplanarBack` depending on their orientation with\n    // respect to this plane. Polygons in front or in back of this plane go into\n    // either `front` or `back`.\n    splitPolygon(polygon, coplanarFront, coplanarBack, front, back) {\n        const COPLANAR = 0;\n        const FRONT = 1;\n        const BACK = 2;\n        const SPANNING = 3;\n        // Classify each point as well as the entire polygon into one of the above\n        // four classes.\n        let polygonType = 0;\n        const types = [];\n        for (let i = 0; i < polygon.vertices.length; i++) {\n            const t = this.normal.dot(polygon.vertices[i].pos) - this.w;\n            const type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\n            polygonType |= type;\n            types.push(type);\n        }\n        // Put the polygon in the correct list, splitting it when necessary.\n        switch (polygonType) {\n            case COPLANAR:\n                (this.normal.dot(polygon.plane.normal) > 0\n                    ? coplanarFront\n                    : coplanarBack).push(polygon);\n                break;\n            case FRONT:\n                front.push(polygon);\n                break;\n            case BACK:\n                back.push(polygon);\n                break;\n            case SPANNING: {\n                const f = [], b = [];\n                for (let i = 0; i < polygon.vertices.length; i++) {\n                    const j = (i + 1) % polygon.vertices.length;\n                    const ti = types[i], tj = types[j];\n                    const vi = polygon.vertices[i], vj = polygon.vertices[j];\n                    if (ti != BACK)\n                        f.push(vi);\n                    if (ti != FRONT)\n                        b.push(ti != BACK ? vi.clone() : vi);\n                    if ((ti | tj) == SPANNING) {\n                        const t = (this.w - this.normal.dot(vi.pos)) /\n                            this.normal.dot(new Vector().copy(vj.pos).sub(vi.pos));\n                        const v = vi.interpolate(vj, t);\n                        f.push(v);\n                        b.push(v.clone());\n                    }\n                }\n                if (f.length >= 3)\n                    front.push(new Polygon(f, polygon.shared));\n                if (b.length >= 3)\n                    back.push(new Polygon(b, polygon.shared));\n                break;\n            }\n        }\n    }\n    static fromPoints(a, b, c) {\n        const n = new Vector()\n            .copy(b)\n            .sub(a)\n            .cross(new Vector().copy(c).sub(a))\n            .normalize();\n        return new Plane(n.clone(), n.dot(a));\n    }\n}\nPlane.EPSILON = 1e-5;\n","import { Plane } from './Plane';\n/**\n * Represents a convex polygon. The vertices used to initialize a polygon must\n * be coplanar and form a convex loop. They do not have to be `Vertex`\n * instances but they must behave similarly (duck typing can be used for\n * customization).\n *\n * Each convex polygon has a `shared` property, which is shared between all\n * polygons that are clones of each other or were split from the same polygon.\n * This can be used to define per-polygon properties (such as surface color).\n */\nexport class Polygon {\n    constructor(vertices, shared) {\n        this.vertices = vertices;\n        this.shared = shared;\n        this.plane = Plane.fromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n    }\n    clone() {\n        return new Polygon(this.vertices.map((v) => v.clone()), this.shared);\n    }\n    flip() {\n        this.vertices.reverse().map((v) => v.flip());\n        this.plane.flip();\n    }\n}\n","import { Vector } from './Vector';\n/**\n * Represents a vertex of a polygon. Use your own vertex class instead of this\n * one to provide additional features like texture coordinates and vertex\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\n * defined by `CSG.Vertex`. This class provides `normal` so convenience\n * functions like `CSG.sphere()` can return a smooth vertex normal, but `normal`\n * is not used anywhere else.\n */\nexport class Vertex {\n    constructor(pos, normal, uv, color) {\n        this.pos = new Vector().copy(pos);\n        this.normal = new Vector().copy(normal);\n        this.uv = new Vector().copy(uv);\n        this.uv.z = 0;\n        color && (this.color = new Vector().copy(color));\n    }\n    clone() {\n        return new Vertex(this.pos, this.normal, this.uv, this.color);\n    }\n    // Invert all orientation-specific data (e.g. vertex normal). Called when the\n    // orientation of a polygon is flipped.\n    flip() {\n        this.normal.negate();\n    }\n    // Create a new vertex between this vertex and `other` by linearly\n    // interpolating all properties using a parameter of `t`. Subclasses should\n    // override this to interpolate additional properties.\n    interpolate(other, t) {\n        return new Vertex(this.pos.clone().lerp(other.pos, t), this.normal.clone().lerp(other.normal, t), this.uv.clone().lerp(other.uv, t), this.color && other.color && this.color.clone().lerp(other.color, t));\n    }\n}\n","import { BufferAttribute, BufferGeometry, Matrix3, Matrix4, Mesh, Vector3, } from 'three';\nimport { NBuf2, NBuf3 } from './NBuf';\nimport { Node } from './Node';\nimport { Polygon } from './Polygon';\nimport { Vector } from './Vector';\nimport { Vertex } from './Vertex';\n/**\n * Holds a binary space partition tree representing a 3D solid. Two solids can\n * be combined using the `union()`, `subtract()`, and `intersect()` methods.\n */\nexport class CSG {\n    constructor() {\n        this.polygons = new Array();\n    }\n    static fromPolygons(polygons) {\n        const csg = new CSG();\n        csg.polygons = polygons;\n        return csg;\n    }\n    static fromGeometry(geom, objectIndex) {\n        let polys = [];\n        const posattr = geom.attributes.position;\n        const normalattr = geom.attributes.normal;\n        const uvattr = geom.attributes.uv;\n        const colorattr = geom.attributes.color;\n        const grps = geom.groups;\n        let index;\n        if (geom.index) {\n            index = geom.index.array;\n        }\n        else {\n            index = new Array((posattr.array.length / posattr.itemSize) | 0);\n            for (let i = 0; i < index.length; i++)\n                index[i] = i;\n        }\n        const triCount = (index.length / 3) | 0;\n        polys = new Array(triCount);\n        for (let i = 0, pli = 0, l = index.length; i < l; i += 3, pli++) {\n            const vertices = new Array(3);\n            for (let j = 0; j < 3; j++) {\n                const vi = index[i + j];\n                const vp = vi * 3;\n                const vt = vi * 2;\n                const x = posattr.array[vp];\n                const y = posattr.array[vp + 1];\n                const z = posattr.array[vp + 2];\n                const nx = normalattr.array[vp];\n                const ny = normalattr.array[vp + 1];\n                const nz = normalattr.array[vp + 2];\n                const u = uvattr === null || uvattr === void 0 ? void 0 : uvattr.array[vt];\n                const v = uvattr === null || uvattr === void 0 ? void 0 : uvattr.array[vt + 1];\n                vertices[j] = new Vertex(new Vector(x, y, z), new Vector(nx, ny, nz), new Vector(u, v, 0), colorattr &&\n                    new Vector(colorattr.array[vt], colorattr.array[vt + 1], colorattr.array[vt + 2]));\n            }\n            if (objectIndex === undefined && grps && grps.length > 0) {\n                for (const grp of grps) {\n                    if (index[i] >= grp.start && index[i] < grp.start + grp.count) {\n                        polys[pli] = new Polygon(vertices, grp.materialIndex);\n                    }\n                }\n            }\n            else {\n                polys[pli] = new Polygon(vertices, objectIndex);\n            }\n        }\n        return CSG.fromPolygons(polys.filter((p) => !isNaN(p.plane.normal.x)));\n    }\n    static toGeometry(csg, toMatrix) {\n        let triCount = 0;\n        const ps = csg.polygons;\n        for (const p of ps) {\n            triCount += p.vertices.length - 2;\n        }\n        const geom = new BufferGeometry();\n        const vertices = new NBuf3(triCount * 3 * 3);\n        const normals = new NBuf3(triCount * 3 * 3);\n        const uvs = new NBuf2(triCount * 2 * 3);\n        let colors;\n        const grps = [];\n        const dgrp = [];\n        for (const p of ps) {\n            const pvs = p.vertices;\n            const pvlen = pvs.length;\n            if (p.shared !== undefined) {\n                if (!grps[p.shared])\n                    grps[p.shared] = [];\n            }\n            if (pvlen && pvs[0].color !== undefined) {\n                if (!colors)\n                    colors = new NBuf3(triCount * 3 * 3);\n            }\n            for (let j = 3; j <= pvlen; j++) {\n                const grp = p.shared === undefined ? dgrp : grps[p.shared];\n                grp.push(vertices.top / 3, vertices.top / 3 + 1, vertices.top / 3 + 2);\n                vertices.write(pvs[0].pos);\n                vertices.write(pvs[j - 2].pos);\n                vertices.write(pvs[j - 1].pos);\n                normals.write(pvs[0].normal);\n                normals.write(pvs[j - 2].normal);\n                normals.write(pvs[j - 1].normal);\n                if (uvs) {\n                    uvs.write(pvs[0].uv);\n                    uvs.write(pvs[j - 2].uv);\n                    uvs.write(pvs[j - 1].uv);\n                }\n                if (colors) {\n                    colors.write(pvs[0].color);\n                    colors.write(pvs[j - 2].color);\n                    colors.write(pvs[j - 1].color);\n                }\n            }\n        }\n        geom.setAttribute('position', new BufferAttribute(vertices.array, 3));\n        geom.setAttribute('normal', new BufferAttribute(normals.array, 3));\n        uvs && geom.setAttribute('uv', new BufferAttribute(uvs.array, 2));\n        colors && geom.setAttribute('color', new BufferAttribute(colors.array, 3));\n        for (let gi = 0; gi < grps.length; gi++) {\n            if (grps[gi] === undefined) {\n                grps[gi] = [];\n            }\n        }\n        if (grps.length) {\n            let index = [];\n            let gbase = 0;\n            for (let gi = 0; gi < grps.length; gi++) {\n                geom.addGroup(gbase, grps[gi].length, gi);\n                gbase += grps[gi].length;\n                index = index.concat(grps[gi]);\n            }\n            geom.addGroup(gbase, dgrp.length, grps.length);\n            index = index.concat(dgrp);\n            geom.setIndex(index);\n        }\n        const inv = new Matrix4().copy(toMatrix).invert();\n        geom.applyMatrix4(inv);\n        geom.computeBoundingSphere();\n        geom.computeBoundingBox();\n        return geom;\n    }\n    static fromMesh(mesh, objectIndex) {\n        const csg = CSG.fromGeometry(mesh.geometry, objectIndex);\n        const ttvv0 = new Vector3();\n        const tmpm3 = new Matrix3();\n        tmpm3.getNormalMatrix(mesh.matrix);\n        for (let i = 0; i < csg.polygons.length; i++) {\n            const p = csg.polygons[i];\n            for (let j = 0; j < p.vertices.length; j++) {\n                const v = p.vertices[j];\n                v.pos.copy(ttvv0.copy(v.pos.toVector3()).applyMatrix4(mesh.matrix));\n                v.normal.copy(ttvv0.copy(v.normal.toVector3()).applyMatrix3(tmpm3));\n            }\n        }\n        return csg;\n    }\n    static toMesh(csg, toMatrix, toMaterial) {\n        const geom = CSG.toGeometry(csg, toMatrix);\n        const m = new Mesh(geom, toMaterial);\n        m.matrix.copy(toMatrix);\n        m.matrix.decompose(m.position, m.quaternion, m.scale);\n        m.rotation.setFromQuaternion(m.quaternion);\n        m.updateMatrixWorld();\n        m.castShadow = m.receiveShadow = true;\n        return m;\n    }\n    static union(meshA, meshB) {\n        const csgA = CSG.fromMesh(meshA);\n        const csgB = CSG.fromMesh(meshB);\n        return CSG.toMesh(csgA.union(csgB), meshA.matrix, meshA.material);\n    }\n    static subtract(meshA, meshB) {\n        const csgA = CSG.fromMesh(meshA);\n        const csgB = CSG.fromMesh(meshB);\n        return CSG.toMesh(csgA.subtract(csgB), meshA.matrix, meshA.material);\n    }\n    static intersect(meshA, meshB) {\n        const csgA = CSG.fromMesh(meshA);\n        const csgB = CSG.fromMesh(meshB);\n        return CSG.toMesh(csgA.intersect(csgB), meshA.matrix, meshA.material);\n    }\n    clone() {\n        const csg = new CSG();\n        csg.polygons = this.polygons\n            .map((p) => p.clone())\n            .filter((p) => Number.isFinite(p.plane.w));\n        return csg;\n    }\n    toPolygons() {\n        return this.polygons;\n    }\n    union(csg) {\n        const a = new Node(this.clone().polygons);\n        const b = new Node(csg.clone().polygons);\n        a.clipTo(b);\n        b.clipTo(a);\n        b.invert();\n        b.clipTo(a);\n        b.invert();\n        a.build(b.allPolygons());\n        return CSG.fromPolygons(a.allPolygons());\n    }\n    subtract(csg) {\n        const a = new Node(this.clone().polygons);\n        const b = new Node(csg.clone().polygons);\n        a.invert();\n        a.clipTo(b);\n        b.clipTo(a);\n        b.invert();\n        b.clipTo(a);\n        b.invert();\n        a.build(b.allPolygons());\n        a.invert();\n        return CSG.fromPolygons(a.allPolygons());\n    }\n    intersect(csg) {\n        const a = new Node(this.clone().polygons);\n        const b = new Node(csg.clone().polygons);\n        a.invert();\n        b.clipTo(a);\n        b.invert();\n        a.clipTo(b);\n        b.clipTo(a);\n        a.build(b.allPolygons());\n        a.invert();\n        return CSG.fromPolygons(a.allPolygons());\n    }\n    // Return a new CSG solid with solid and empty space switched. This solid is\n    // not modified.\n    inverse() {\n        const csg = this.clone();\n        for (const p of csg.polygons) {\n            p.flip();\n        }\n        return csg;\n    }\n    toMesh(toMatrix, toMaterial) {\n        return CSG.toMesh(this, toMatrix, toMaterial);\n    }\n    toGeometry(toMatrix) {\n        return CSG.toGeometry(this, toMatrix);\n    }\n}\n"],"names":["NBuf3","constructor","ct","this","top","array","Float32Array","write","v","x","y","z","NBuf2","Node","polygons","plane","front","back","build","clone","node","map","p","invert","i","length","flip","temp","clipPolygons","slice","Array","splitPolygon","concat","clipTo","bsp","allPolygons","Vector","copy","negate","add","a","sub","times","dividedBy","lerp","t","unit","Math","sqrt","pow","normalize","cross","b","ax","ay","az","bx","by","bz","dot","toVector3","Vector3","Plane","normal","w","polygon","coplanarFront","coplanarBack","COPLANAR","FRONT","BACK","SPANNING","polygonType","types","vertices","pos","type","EPSILON","push","f","j","ti","tj","vi","vj","interpolate","Polygon","shared","static","c","n","fromPoints","reverse","Vertex","uv","color","other","CSG","csg","geom","objectIndex","polys","posattr","attributes","position","normalattr","uvattr","colorattr","grps","groups","index","itemSize","triCount","pli","l","vp","vt","nx","ny","nz","u","undefined","grp","start","count","materialIndex","fromPolygons","filter","isNaN","toMatrix","ps","BufferGeometry","normals","uvs","colors","dgrp","pvs","pvlen","setAttribute","BufferAttribute","gi","gbase","addGroup","setIndex","inv","Matrix4","applyMatrix4","computeBoundingSphere","computeBoundingBox","mesh","fromGeometry","geometry","ttvv0","tmpm3","Matrix3","getNormalMatrix","matrix","applyMatrix3","toMaterial","toGeometry","m","Mesh","decompose","quaternion","scale","rotation","setFromQuaternion","updateMatrixWorld","castShadow","receiveShadow","meshA","meshB","csgA","fromMesh","csgB","toMesh","union","material","subtract","intersect","Number","isFinite","toPolygons","inverse"],"mappings":"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"}
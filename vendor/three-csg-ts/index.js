import{Vector3 as t,BufferGeometry as o,BufferAttribute as s,Matrix4 as e,Matrix3 as n,Mesh as r}from"three";class NBuf3{constructor(t){this.top=0;this.array=new Float32Array(t)}write(t){this.array[this.top++]=t.x;this.array[this.top++]=t.y;this.array[this.top++]=t.z}}class NBuf2{constructor(t){this.top=0;this.array=new Float32Array(t)}write(t){this.array[this.top++]=t.x;this.array[this.top++]=t.y}}class Node{constructor(t){this.plane=null;this.front=null;this.back=null;this.polygons=[];t&&this.build(t)}clone(){const t=new Node;t.plane=this.plane&&this.plane.clone();t.front=this.front&&this.front.clone();t.back=this.back&&this.back.clone();t.polygons=this.polygons.map((t=>t.clone()));return t}invert(){for(let t=0;t<this.polygons.length;t++)this.polygons[t].flip();this.plane&&this.plane.flip();this.front&&this.front.invert();this.back&&this.back.invert();const t=this.front;this.front=this.back;this.back=t}clipPolygons(t){if(!this.plane)return t.slice();let o=new Array,s=new Array;for(let e=0;e<t.length;e++)this.plane.splitPolygon(t[e],o,s,o,s);this.front&&(o=this.front.clipPolygons(o));s=this.back?this.back.clipPolygons(s):[];return o.concat(s)}clipTo(t){this.polygons=t.clipPolygons(this.polygons);this.front&&this.front.clipTo(t);this.back&&this.back.clipTo(t)}allPolygons(){let t=this.polygons.slice();this.front&&(t=t.concat(this.front.allPolygons()));this.back&&(t=t.concat(this.back.allPolygons()));return t}build(t){if(!t.length)return;this.plane||(this.plane=t[0].plane.clone());const o=[],s=[];for(let e=0;e<t.length;e++)this.plane.splitPolygon(t[e],this.polygons,this.polygons,o,s);if(o.length){this.front||(this.front=new Node);this.front.build(o)}if(s.length){this.back||(this.back=new Node);this.back.build(s)}}}class Vector{constructor(t=0,o=0,s=0){this.x=t;this.y=o;this.z=s}copy(t){this.x=t.x;this.y=t.y;this.z=t.z;return this}clone(){return new Vector(this.x,this.y,this.z)}negate(){this.x*=-1;this.y*=-1;this.z*=-1;return this}add(t){this.x+=t.x;this.y+=t.y;this.z+=t.z;return this}sub(t){this.x-=t.x;this.y-=t.y;this.z-=t.z;return this}times(t){this.x*=t;this.y*=t;this.z*=t;return this}dividedBy(t){this.x/=t;this.y/=t;this.z/=t;return this}lerp(t,o){return this.add((new Vector).copy(t).sub(this).times(o))}unit(){return this.dividedBy(this.length())}length(){return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2)+Math.pow(this.z,2))}normalize(){return this.unit()}cross(t){const o=this.clone();const s=o.x,e=o.y,n=o.z;const r=t.x,i=t.y,l=t.z;this.x=e*l-n*i;this.y=n*r-s*l;this.z=s*i-e*r;return this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}toVector3(){return new t(this.x,this.y,this.z)}}class Plane{constructor(t,o){this.normal=t;this.w=o;this.normal=t;this.w=o}clone(){return new Plane(this.normal.clone(),this.w)}flip(){this.normal.negate();this.w=-this.w}splitPolygon(t,o,s,e,n){const r=0;const i=1;const l=2;const c=3;let h=0;const a=[];for(let o=0;o<t.vertices.length;o++){const s=this.normal.dot(t.vertices[o].pos)-this.w;const e=s<-Plane.EPSILON?l:s>Plane.EPSILON?i:r;h|=e;a.push(e)}switch(h){case r:(this.normal.dot(t.plane.normal)>0?o:s).push(t);break;case i:e.push(t);break;case l:n.push(t);break;case c:{const o=[],s=[];for(let e=0;e<t.vertices.length;e++){const n=(e+1)%t.vertices.length;const r=a[e],h=a[n];const p=t.vertices[e],y=t.vertices[n];r!=l&&o.push(p);r!=i&&s.push(r!=l?p.clone():p);if((r|h)==c){const t=(this.w-this.normal.dot(p.pos))/this.normal.dot((new Vector).copy(y.pos).sub(p.pos));const e=p.interpolate(y,t);o.push(e);s.push(e.clone())}}o.length>=3&&e.push(new Polygon(o,t.shared));s.length>=3&&n.push(new Polygon(s,t.shared));break}}}static fromPoints(t,o,s){const e=(new Vector).copy(o).sub(t).cross((new Vector).copy(s).sub(t)).normalize();return new Plane(e.clone(),e.dot(t))}}Plane.EPSILON=1e-5;class Polygon{constructor(t,o){this.vertices=t;this.shared=o;this.plane=Plane.fromPoints(t[0].pos,t[1].pos,t[2].pos)}clone(){return new Polygon(this.vertices.map((t=>t.clone())),this.shared)}flip(){this.vertices.reverse().map((t=>t.flip()));this.plane.flip()}}class Vertex{constructor(t,o,s,e){this.pos=(new Vector).copy(t);this.normal=(new Vector).copy(o);this.uv=(new Vector).copy(s);this.uv.z=0;e&&(this.color=(new Vector).copy(e))}clone(){return new Vertex(this.pos,this.normal,this.uv,this.color)}flip(){this.normal.negate()}interpolate(t,o){return new Vertex(this.pos.clone().lerp(t.pos,o),this.normal.clone().lerp(t.normal,o),this.uv.clone().lerp(t.uv,o),this.color&&t.color&&this.color.clone().lerp(t.color,o))}}class CSG{constructor(){this.polygons=new Array}static fromPolygons(t){const o=new CSG;o.polygons=t;return o}static fromGeometry(t,o){let s=[];const e=t.attributes.position;const n=t.attributes.normal;const r=t.attributes.uv;const i=t.attributes.color;const l=t.groups;let c;if(t.index)c=t.index.array;else{c=new Array(e.array.length/e.itemSize|0);for(let t=0;t<c.length;t++)c[t]=t}const h=c.length/3|0;s=new Array(h);for(let t=0,h=0,a=c.length;t<a;t+=3,h++){const a=new Array(3);for(let o=0;o<3;o++){const s=c[t+o];const l=3*s;const h=2*s;const p=e.array[l];const y=e.array[l+1];const u=e.array[l+2];const g=n.array[l];const w=n.array[l+1];const f=n.array[l+2];const m=null===r||void 0===r?void 0:r.array[h];const d=null===r||void 0===r?void 0:r.array[h+1];a[o]=new Vertex(new Vector(p,y,u),new Vector(g,w,f),new Vector(m,d,0),i&&new Vector(i.array[h],i.array[h+1],i.array[h+2]))}if(void 0===o&&l&&l.length>0)for(const o of l)c[t]>=o.start&&c[t]<o.start+o.count&&(s[h]=new Polygon(a,o.materialIndex));else s[h]=new Polygon(a,o)}return CSG.fromPolygons(s.filter((t=>!isNaN(t.plane.normal.x))))}static toGeometry(t,n){let r=0;const i=t.polygons;for(const t of i)r+=t.vertices.length-2;const l=new o;const c=new NBuf3(3*r*3);const h=new NBuf3(3*r*3);const a=new NBuf2(2*r*3);let p;const y=[];const u=[];for(const t of i){const o=t.vertices;const s=o.length;void 0!==t.shared&&(y[t.shared]||(y[t.shared]=[]));s&&void 0!==o[0].color&&(p||(p=new NBuf3(3*r*3)));for(let e=3;e<=s;e++){const s=void 0===t.shared?u:y[t.shared];s.push(c.top/3,c.top/3+1,c.top/3+2);c.write(o[0].pos);c.write(o[e-2].pos);c.write(o[e-1].pos);h.write(o[0].normal);h.write(o[e-2].normal);h.write(o[e-1].normal);if(a){a.write(o[0].uv);a.write(o[e-2].uv);a.write(o[e-1].uv)}if(p){p.write(o[0].color);p.write(o[e-2].color);p.write(o[e-1].color)}}}l.setAttribute("position",new s(c.array,3));l.setAttribute("normal",new s(h.array,3));a&&l.setAttribute("uv",new s(a.array,2));p&&l.setAttribute("color",new s(p.array,3));for(let t=0;t<y.length;t++)void 0===y[t]&&(y[t]=[]);if(y.length){let t=[];let o=0;for(let s=0;s<y.length;s++){l.addGroup(o,y[s].length,s);o+=y[s].length;t=t.concat(y[s])}l.addGroup(o,u.length,y.length);t=t.concat(u);l.setIndex(t)}const g=(new e).copy(n).invert();l.applyMatrix4(g);l.computeBoundingSphere();l.computeBoundingBox();return l}static fromMesh(o,s){const e=CSG.fromGeometry(o.geometry,s);const r=new t;const i=new n;i.getNormalMatrix(o.matrix);for(let t=0;t<e.polygons.length;t++){const s=e.polygons[t];for(let t=0;t<s.vertices.length;t++){const e=s.vertices[t];e.pos.copy(r.copy(e.pos.toVector3()).applyMatrix4(o.matrix));e.normal.copy(r.copy(e.normal.toVector3()).applyMatrix3(i))}}return e}static toMesh(t,o,s){const e=CSG.toGeometry(t,o);const n=new r(e,s);n.matrix.copy(o);n.matrix.decompose(n.position,n.quaternion,n.scale);n.rotation.setFromQuaternion(n.quaternion);n.updateMatrixWorld();n.castShadow=n.receiveShadow=true;return n}static union(t,o){const s=CSG.fromMesh(t);const e=CSG.fromMesh(o);return CSG.toMesh(s.union(e),t.matrix,t.material)}static subtract(t,o){const s=CSG.fromMesh(t);const e=CSG.fromMesh(o);return CSG.toMesh(s.subtract(e),t.matrix,t.material)}static intersect(t,o){const s=CSG.fromMesh(t);const e=CSG.fromMesh(o);return CSG.toMesh(s.intersect(e),t.matrix,t.material)}clone(){const t=new CSG;t.polygons=this.polygons.map((t=>t.clone())).filter((t=>Number.isFinite(t.plane.w)));return t}toPolygons(){return this.polygons}union(t){const o=new Node(this.clone().polygons);const s=new Node(t.clone().polygons);o.clipTo(s);s.clipTo(o);s.invert();s.clipTo(o);s.invert();o.build(s.allPolygons());return CSG.fromPolygons(o.allPolygons())}subtract(t){const o=new Node(this.clone().polygons);const s=new Node(t.clone().polygons);o.invert();o.clipTo(s);s.clipTo(o);s.invert();s.clipTo(o);s.invert();o.build(s.allPolygons());o.invert();return CSG.fromPolygons(o.allPolygons())}intersect(t){const o=new Node(this.clone().polygons);const s=new Node(t.clone().polygons);o.invert();s.clipTo(o);s.invert();o.clipTo(s);s.clipTo(o);o.build(s.allPolygons());o.invert();return CSG.fromPolygons(o.allPolygons())}inverse(){const t=this.clone();for(const o of t.polygons)o.flip();return t}toMesh(t,o){return CSG.toMesh(this,t,o)}toGeometry(t){return CSG.toGeometry(this,t)}}export{CSG};

//# sourceMappingURL=index.js.map